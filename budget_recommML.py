# -*- coding: utf-8 -*-
"""budget recomm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H9BXy-8HQ9w2ZATmo-QeWPtWHebOnRog
"""

from google.colab import drive
import pandas as pd

# Mount Drive
drive.mount('/content/drive')

# Import libraries
# -----------------------------
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import IsolationForest
import ipywidgets as widgets
from IPython.display import display, clear_output

# Load preprocessed dataset
# -----------------------------
file_path = '/content/drive/MyDrive/data_usd_preprocessed.csv'
df = pd.read_csv(file_path)

# Features for spending
features = ['Rent','Groceries','Transport','Eating_Out','Entertainment','Utilities']
df.head()

# Spending features
features = ['Rent','Groceries','Transport','Eating_Out','Entertainment','Utilities']

# Average spending and income
average_spend = df[features].mean()
average_income = df['Income'].mean()

# Isolation Forest for anomaly detection
# -----------------------------
X = df[features]
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

clf = IsolationForest(contamination=0.1, random_state=42)
clf.fit(X_scaled)

def check_anomaly(user_input):
    user_values = np.array([user_input[feat] for feat in features]).reshape(1, -1)
    user_scaled = scaler.transform(user_values)
    result = clf.predict(user_scaled)
    return "âš ï¸ Overspending detected!" if result[0] == -1 else "âœ… Spending is normal"

# Create interactive widgets
# -----------------------------
inputs = {}
for feature in features:
    inputs[feature] = widgets.FloatText(
        value=average_spend[feature],
        description=feature,
        step=0.01
    )

user_income = widgets.FloatText(
    value=average_income,
    description="Income",
    step=0.01
)

submit_button = widgets.Button(description="Get Recommendations")
reset_button = widgets.Button(description="Reset")
output = widgets.Output()

# Recommendation logic with income-aware savings
# -----------------------------
def recommend_budget(user_input, income):
    recommendation = {}
    potential_savings = 0

    for feature in features:
        spent = user_input[feature]
        spent_ratio = spent / income
        avg_ratio = average_spend[feature] / average_income

        if spent_ratio > avg_ratio:
            # calculate realistic saving: cannot save more than what user actually spent
            saving = min(spent - (avg_ratio * income), spent)
            saving = max(saving, 0)  # avoid negative savings
            recommendation[feature] = f"Spend less (save ${round(saving,2)})"
            potential_savings += saving
        else:
            recommendation[feature] = "Spend okay / Could spend more"

    # Cap total savings to income
    potential_savings = min(potential_savings, income)
    return recommendation, round(potential_savings,2)

# Button actions
# -----------------------------
def on_submit_button_clicked(b):
    clear_output()
    display(widgets.VBox(list(inputs.values()) + [user_income, submit_button, reset_button]))

    # Collect user input
    user_input = {feature: inputs[feature].value for feature in features}
    income_val = user_income.value

    # Get recommendations
    recommendation, savings = recommend_budget(user_input, income_val)
    anomaly_msg = check_anomaly(user_input)

    print("\nðŸ’¡ Budget Recommendations:")
    for k,v in recommendation.items():
        print(f"- {k}: {v}")
    print(f"\nðŸ’° Potential total savings if following advice: ${savings}")
    print("\n" + anomaly_msg)

def on_reset_button_clicked(b):
    for feature in features:
        inputs[feature].value = average_spend[feature]
    user_income.value = average_income

submit_button.on_click(on_submit_button_clicked)
reset_button.on_click(on_reset_button_clicked)

# Display widgets
# -----------------------------
display(widgets.VBox(list(inputs.values()) + [user_income, submit_button, reset_button]))